using System.Runtime.InteropServices;
using System.Text;

namespace Otterkit;

public static partial class Tools
{
    private const string CaseFoldPath = "../Libraries/Otterkit.Runtime/src/Generated/CaseFoldLookup.cs";

    public static void GenerateCaseFold()
    {
        var builder = new StringBuilder();

        builder.AppendLine("// This file is auto-generated by Otterkit, do not edit manually.");
        builder.AppendLine("// Compiler Tool: src/Tools/GenerateCaseFold.cs");
        builder.AppendLine("namespace Otterkit.Runtime;\n");
        builder.AppendLine("public static partial class RuntimeHelpers");
        builder.AppendLine("{");

        builder.AppendLine("    public static readonly byte[] CaseFoldData = new byte[]");
        builder.AppendLine("    {");

        for (int i = 0; i < CaseFoldData.Length; i += 2)
        {
            var mapping = CaseFoldData[i + 1];

            var mappingString = Char.ConvertFromUtf32(Convert.ToInt32(mapping, 16));

            var mappingBytes = Encoding.UTF8.GetBytes(mappingString);

            GenerateCaseFoldData(builder, mappingBytes);

            builder.AppendLine(",");
        }

        builder.AppendLine("    };\n");

        builder.AppendLine("    // This method performs UTF-8 simple case folding.");
        builder.AppendLine("    public static int CaseFoldLookup(ReadOnlySpan<byte> u8String)");
        builder.AppendLine("    {");
        builder.AppendLine("        return u8String switch");
        builder.AppendLine("        {");

        var index = 0;

        for (int i = 0; i < CaseFoldData.Length; i += 2)
        {
            var code = CaseFoldData[i];
            var mapping = CaseFoldData[i + 1];

            var codeString = Char.ConvertFromUtf32(Convert.ToInt32(code, 16));

            var mappingString = Char.ConvertFromUtf32(Convert.ToInt32(mapping, 16));

            var codeBytes = Encoding.UTF8.GetBytes(codeString);

            var mappingBytes = Encoding.UTF8.GetBytes(mappingString);

            GenerateSwitchCaseFold(builder, codeBytes, index);

            index += mappingBytes.Length;
        }

        builder.AppendLine("            _ => -1");
        builder.AppendLine("        };");
        builder.AppendLine("    }");
        builder.AppendLine("}");

        File.WriteAllText(CaseFoldPath, builder.ToString());
    }

    public static void GenerateCaseFoldData(StringBuilder builder, ReadOnlySpan<byte> mapping)
    {
        var length = mapping.Length;

        var mappingEntry = length switch
        {
            1 => $"        0x{mapping[0]:X2}",
            2 => $"        0x{mapping[0]:X2}, 0x{mapping[1]:X2}",
            3 => $"        0x{mapping[0]:X2}, 0x{mapping[1]:X2}, 0x{mapping[2]:X2}",
            4 => $"        0x{mapping[0]:X2}, 0x{mapping[1]:X2}, 0x{mapping[2]:X2}, 0x{mapping[3]:X2}",
            _ => throw new Exception("Invalid mapping length")
        };

        builder.Append(mappingEntry);
    }

    public static void GenerateSwitchCaseFold(StringBuilder builder, ReadOnlySpan<byte> code, int index)
    {
        builder.Append("            [");
        
        var codeLength = code.Length;

        var codeString = codeLength switch
        {
            1 => $"{code[0]}, ..] => {index},",
            2 => $"{code[0]}, {code[1]}, ..] => {index},",
            3 => $"{code[0]}, {code[1]}, {code[2]}, ..] => {index},",
            4 => $"{code[0]}, {code[1]}, {code[2]}, {code[3]}, ..] => {index},",
            _ => throw new Exception("Invalid code point length")
        };

        builder.AppendLine(codeString);
    }
}
